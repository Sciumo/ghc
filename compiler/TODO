## TODO FIRST

* write a testsuite named kinds with everything I can think of
  - translate Faking it (Conor)
  - when translating, add a reference to the thing being translated

* write a user manual
  - haskell.org/haskellwiki/GHC/kinds
    describe informally how we can use them


## TODO NEXT

* step2(notations)
  data HsType name = ... | HsOpTy (LHsType name) (LHsTyOp name) (LHsType name) | ...
  type HsTyOp name = (HsTyWrapper, name)


## BUGS

* We do not track ticks in Iface, so [ 'List * ] gets printed [ List * ].
  We can look at the namespace of the OccName to know if we print a tick (works only for lifted data, since we don't know if we are in a type or kind context).

* Error messages for things like:
  data T (a : 'T -> *) = MkT (a 'MkT)

* Promoted primitive negative integers are not parsed.
  > f :: -1

* Operators are not printed correctly. See bug/Operators.hs.

* Kinds are not always printed correctly.
  (*, *) instead of '(*, *)
  [*] instead of '[*]
  We might add a Promoted flag in HsTupleTy and HsListTy.


## OPTIONAL

* Pattern match(es) are non-exhaustive (splitAt in Vector.hs)
  The problem is already there in master.

* No wildpat in types.  Neither is there a warning on unused variables.

* What about lifting type operators?

* Maybe want to merge UserTyVar and KindedTyVar

* ''a' -> ITtyvar a'
  instead of ITsimplequote 'a'

* Getting rid of subkinding.

  kappa ::= eta | # | (#) | ? | ??
  eta ::= * | eta -> eta | T eta .. eta

  Gamma, alpha : ??, x : alpha |- e
  ----------------------------------
  Gamma |- \x -> e

  error : forall (a : ?). String -> a  (still weird)

  Gamma |- tau : kappa1 in * or #
  Gamma |- sigma : kappa2 in * or # or (#)
  ----------------------------------------
  Gamma |- tau -> sigma : *

  ? and ?? only appear at top level, and they always get set to star
  when unified with a meta kind variable

* data HsExpr id = ... | HsOpApp .. (HsOp id) .. | ...
  type HsOp name = (name, Fixity, HsWrapper)

* Make `+' be a TcClsName instead of VarName:
  data a + b = Left a | Right b

* Kind generalize instead of zonking to kind
  > data SList s as where
  >   SNil :: SList s Nil
  >   SCons :: s a -> SList s as -> SList s (Cons a as)
  would return SList :: forall (k :: BOX). (k -> *) -> List k -> *
  and not SList :: (* -> *) -> List * -> *


----------------------------------------------------------------------
--                             HELPERS                              --
----------------------------------------------------------------------

  1. How to check conflicts in the parser

% cd compiler/parser
% gcc -E -undef -traditional -P -Iincludes -x c Parser.y.pp | grep -v '^#pragma GCC' >! Parser.y && happy -agc --strict Parser.y -i

